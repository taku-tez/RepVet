/**
 * Dart/Flutter ecosystem parser
 * - pubspec.lock
 */

import { PackageDependency } from '../types.js';

/**
 * Parse pubspec.lock (Dart/Flutter)
 *
 * Format: YAML-like structure
 * ```
 * # Generated by pub
 * # See https://dart.dev/tools/pub/glossary#lockfile
 * packages:
 *   http:
 *     dependency: "direct main"
 *     description:
 *       name: http
 *       sha256: "..."
 *       url: "https://pub.dev"
 *     source: hosted
 *     version: "1.2.0"
 *   flutter:
 *     dependency: "direct main"
 *     description: flutter
 *     source: sdk
 *     version: "0.0.0"
 * sdks:
 *   dart: ">=3.0.0 <4.0.0"
 * ```
 *
 * We only extract packages with source: hosted (from pub.dev registry).
 * SDK dependencies (flutter, dart) and path/git sources are skipped.
 */
export function parsePubspecLock(content: string): PackageDependency[] {
  const deps: PackageDependency[] = [];
  const seen = new Set<string>();
  const lines = content.split('\n');

  let inPackages = false;
  let currentPackage: string | null = null;
  let currentVersion: string | null = null;
  let currentSource: string | null = null;
  let indent = 0;

  for (const line of lines) {
    // Detect "packages:" top-level section
    if (/^packages:\s*$/.test(line)) {
      inPackages = true;
      continue;
    }

    // End of packages section (new top-level key like "sdks:")
    if (inPackages && /^[a-z]/.test(line) && !line.startsWith(' ')) {
      // Flush last package
      if (currentPackage && currentSource === 'hosted' && !seen.has(currentPackage)) {
        seen.add(currentPackage);
        deps.push({ name: currentPackage, version: currentVersion || undefined });
      }
      inPackages = false;
      currentPackage = null;
      currentVersion = null;
      currentSource = null;
      continue;
    }

    if (!inPackages) continue;

    // Package name line: exactly 2 spaces + name + colon
    const pkgMatch = line.match(/^  ([a-zA-Z0-9_]+):\s*$/);
    if (pkgMatch) {
      // Flush previous package
      if (currentPackage && currentSource === 'hosted' && !seen.has(currentPackage)) {
        seen.add(currentPackage);
        deps.push({ name: currentPackage, version: currentVersion || undefined });
      }
      currentPackage = pkgMatch[1];
      currentVersion = null;
      currentSource = null;
      indent = 2;
      continue;
    }

    if (!currentPackage) continue;

    // source: hosted | sdk | path | git
    const sourceMatch = line.match(/^\s+source:\s*(\S+)/);
    if (sourceMatch) {
      currentSource = sourceMatch[1];
      continue;
    }

    // version: "x.y.z"
    const versionMatch = line.match(/^\s+version:\s*"([^"]+)"/);
    if (versionMatch) {
      currentVersion = versionMatch[1];
      continue;
    }
  }

  // Flush last package if file ends inside packages section
  if (currentPackage && currentSource === 'hosted' && !seen.has(currentPackage)) {
    seen.add(currentPackage);
    deps.push({ name: currentPackage, version: currentVersion || undefined });
  }

  return deps;
}
