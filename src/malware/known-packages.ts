/**
 * Known malware packages database
 * Source: npm advisories, Snyk, Socket.dev, CISA alerts
 * Data loaded from data/malware-db.json
 */

import { readFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';

/**
 * Malware entry type
 */
export interface MalwareEntry {
  name: string;
  year: number;
  description: string;
  severity: 'critical' | 'high' | 'medium';
  type: 'supply-chain' | 'typosquat' | 'sabotage' | 'protestware' | 'crypto-stealer';
  ecosystem?: string;
}

/**
 * Malware database structure
 */
interface MalwareDb {
  version: string;
  lastUpdated: string;
  packages: MalwareEntry[];
}

// Resolve path to data file
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const DATA_PATH = join(__dirname, '../../data/malware-db.json');

/**
 * Load malware database from JSON file
 */
function loadMalwareDb(): MalwareDb {
  try {
    const data = readFileSync(DATA_PATH, 'utf-8');
    return JSON.parse(data) as MalwareDb;
  } catch {
    // Fallback to empty database if file not found
    console.warn(`Warning: Could not load malware database from ${DATA_PATH}`);
    return { version: '0.0.0', lastUpdated: '', packages: [] };
  }
}

// Load database once at module initialization
const malwareDb = loadMalwareDb();

// Build lookup structures
const KNOWN_MALWARE_PACKAGES = new Set(malwareDb.packages.map(p => p.name));

// Map from name.toLowerCase() -> list of entries (may have multiple ecosystems)
const MALWARE_ENTRIES_BY_NAME: Record<string, MalwareEntry[]> = {};
for (const entry of malwareDb.packages) {
  const key = entry.name.toLowerCase();
  if (!MALWARE_ENTRIES_BY_NAME[key]) {
    MALWARE_ENTRIES_BY_NAME[key] = [];
  }
  MALWARE_ENTRIES_BY_NAME[key].push(entry);
}

/**
 * Find matching malware entry considering ecosystem
 * Returns the entry if:
 * - Entry has no ecosystem (matches all)
 * - Entry's ecosystem matches the provided ecosystem
 * - No ecosystem is provided (matches any entry)
 */
function findMatchingEntry(packageName: string, ecosystem?: string): MalwareEntry | null {
  const entries = MALWARE_ENTRIES_BY_NAME[packageName.toLowerCase()];
  if (!entries) return null;
  
  // If no ecosystem provided, return first entry
  if (!ecosystem) {
    return entries[0];
  }
  
  // Find entry that matches ecosystem or has no ecosystem specified
  for (const entry of entries) {
    if (!entry.ecosystem || entry.ecosystem === ecosystem) {
      return entry;
    }
  }
  
  return null;
}

/**
 * Check if a package has known malware history
 * @param packageName - Package name to check
 * @param ecosystem - Optional ecosystem to filter by
 */
export function hasMalwareHistory(packageName: string, ecosystem?: string): boolean {
  return findMatchingEntry(packageName, ecosystem) !== null;
}

/**
 * Get malware details if known
 * @param packageName - Package name to check
 * @param ecosystem - Optional ecosystem to filter by
 */
export function getMalwareDetails(packageName: string, ecosystem?: string): string | null {
  const info = findMatchingEntry(packageName, ecosystem);
  if (info) {
    return `${info.description} (${info.year})`;
  }
  
  return null;
}

/**
 * Get full malware info
 * @param packageName - Package name to check
 * @param ecosystem - Optional ecosystem to filter by
 */
export function getMalwareInfo(packageName: string, ecosystem?: string): MalwareEntry | null {
  return findMatchingEntry(packageName, ecosystem);
}

/**
 * Get all known malware package names
 */
export function getAllMalwarePackages(): string[] {
  return Array.from(KNOWN_MALWARE_PACKAGES);
}

/**
 * Get database metadata
 */
export function getMalwareDbInfo(): { version: string; lastUpdated: string; count: number } {
  return {
    version: malwareDb.version,
    lastUpdated: malwareDb.lastUpdated,
    count: malwareDb.packages.length,
  };
}

// Export for backward compatibility
export { KNOWN_MALWARE_PACKAGES };
